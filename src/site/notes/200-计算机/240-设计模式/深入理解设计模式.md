---
{"dg-publish":true,"permalink":"/200/240//","tags":["Read/doing","Java"],"noteIcon":""}
---

## [[200-计算机/240-设计模式/OOP\|OOP]]

## [[200-计算机/240-设计模式/对象之间的关系\|对象之间的关系]]

## 模式类别

### 创建型模式

#### 工厂模式

##### 产品
- Product
- 对**接口**进行声明

##### 具体产品
- Concrete Products
- 产品**接口**的不同**实现**

##### 创建者
- Creator
- **声明**返回产品对象的工厂**方法**

##### 具体创建者
- Concrete Creators
- 重写基础工厂方法，使其返回不同类型的产品。

#### 抽象工厂模式

##### 抽象产品

- Abstract Product
-  构成系列产品的一组不同但相关的产品**声明接口**。

##### 具体产品
- Concrete Product
- 抽象产品的多种不同**类型实现**。

##### 抽象工厂
- Abstract Factory
- **接口声明**了一组创建各种抽象产品的方法。

##### 具体工厂
- Concrete Factory
- **实现**抽象工厂的构建**方法**
- 工厂方法也可以返回缓存、对象池或其他来源的已有对象


#### 生成器

##### 生成器
- Builder
- **接口声明**在所有类型生成器中通用的产品构造步骤。

##### 具体生成器
- Concrete Builders
- 提供构造过程的不同实现
- 具体生成器也可以构造不遵循通用接口的产品

##### 产品
- Products
- 最终生成的对象

##### 主管
- Director
- 定义调用构造步骤的顺序，这样你就可以创建和复用特定的产品配置。

##### 客户端
- Client
- 必须将某个生成器对象与主管类关联。

#### 原型模式


#### 单例模式

### 结构型模式

### 行为模式


## 封装变化的内容

### 方法层面的封装

### 类层面的封装
 
## 设计原则


## 面向接口开发

## SOLID 原则

### S：单依职责原则
- Single Responsibility Principle
- 修改一个类的原因只能有一个。

### O：开闭原则
- Open/closed Principle
- 对于扩展，类应该是“开放”的；对于修改，类则应是“封闭”的。

### L：里氏替换原则
- Liskov Substitution Principle
- 当你扩展一个类时， 记住你应该要能在不修改客户端代码的情况下将子类的对象作为父类对象进行传递。

#### 子类方法的参数类型必须与其超类的参数类型相匹配或更加抽象
#### 子类方法的返回值类型必须与超类方法的返回值类型或是其子类别相匹配。
#### 子类中的方法不应抛出基础方法预期之外的异常类型。
#### 子类不应该加强其前置条件。
#### 子类不能削弱其后置条件。

### I：接口隔离原则
- Interface Segregation Principle
- 客户端不应被强迫依赖于其不使用的方法。


### D：依赖倒置原则
- Dependency Inversion Principle
- 高层次的类不应该依赖于低层次的类。 两者都应该依赖于抽象接口。 抽象接口不应依赖于具体实现。 具体实现应该依赖于抽象接口。



[[200-计算机/240-设计模式/深入理解设计模式#创建型模式\|深入理解设计模式#创建型模式]]